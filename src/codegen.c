/* codegen.c - implementation of generation of a `ks_code` object from an AST */

#include "ks.h"


// a structure describing code-generation-information (cgi)
typedef struct cgi {

    // variable keeping track of where the stack is currently
    int stk_depth;

    // variable keeping track how many ast recursion calls it is deep
    int call_depth;

    // the last AST on the main block level of the AST, useful for making sure a return is at
    //   the end of the bytecode
    ks_ast last_main;


}* cgi;


// internal method to generate code
static void codegen(ks_ast self, ks_code to, cgi geni) {
    /* strategy for code generation:

    We want to keep the stack balanced so that, say, recursive functions can work without the stack becoming
      corrupted, so we store the current stack depth in `geni` (generation information)
    
    Some operations produce values on the stack (like loading a constant), and some take them off (function calls),
      so we sum these up to get our current stack position.

    Some ASTs, like blocks, must destroy any left over values on the top of the stack, because they 'yield' nothing to the stack

    */

    geni->call_depth++;

    if (self == NULL) {
        kse_add("Given NULL AST in codegen()");
        return;
    }

    // loop variable
    int i;

    // capture where we started
    int stk_depth_start = geni->stk_depth;

    // grows the stack by `_n`
    #define STK_GROW(_n) { geni->stk_depth += _n; }

    // makes sure the stk only grows by `_rel`, set _rel=0 for no change in stack depth, i.e. remove all additional things generated by children
    #define STK_TO(_rel) { while (geni->stk_depth > stk_depth_start + _rel) { geni->stk_depth--; ksc_popu(to); } }

    switch (self->atype)
    {
    case KS_AST_INT:
        ksc_int(to, self->v_int->v_int);
        STK_GROW(1);
        break;
    case KS_AST_STR:
        ksc_cstr(to, self->v_str->chr);
        STK_GROW(1);
        break;
    case KS_AST_TRUE:
        ksc_const_true(to);
        STK_GROW(1);
        break;
    case KS_AST_FALSE:
        ksc_const_false(to);
        STK_GROW(1);
        break;
    case KS_AST_NONE:
        ksc_const_none(to);
        STK_GROW(1);
        break;

    case KS_AST_VAR:
        ksc_load(to, self->v_var->chr);
        STK_GROW(1);
        break;

    case KS_AST_BOP_ADD:
    case KS_AST_BOP_SUB:
    case KS_AST_BOP_MUL:
    case KS_AST_BOP_DIV:
        // all binary operators
        // generate both children
        codegen(self->v_bop.L, to, geni);
        codegen(self->v_bop.R, to, geni);

        /**/ if (self->atype == KS_AST_BOP_ADD) ksc_add(to);
        else if (self->atype == KS_AST_BOP_SUB) ksc_sub(to);
        else if (self->atype == KS_AST_BOP_MUL) ksc_mul(to);
        else if (self->atype == KS_AST_BOP_DIV) ksc_div(to);

        // pop 2, but push result back on
        STK_GROW(1 - 2);

        break;


    case KS_AST_CALL:

        // calculate all the children
        for (i = 0; i < self->v_call->len; ++i) {
            codegen((ks_ast)self->v_call->items[i], to, geni);
        }

        // call those items on the stack
        ksc_call(to, self->v_call->len);

        // 1 is for the result of the function, minus all the things used to call it
        STK_GROW(1 - self->v_call->len);
        break;

    case KS_AST_CODE:

        // output some literal assembly, by linking it in using the method provided in kso.c
        // this will also merge the constants list
        ks_code_linkin(to, self->v_code);

        break;
    
    case KS_AST_BLOCK:

        // output all the sub block items
        for (i = 0; i < self->v_block->len; ++i) {
            codegen((ks_ast)self->v_block->items[i], to, geni);

            // discard any modifications made to the stack by these items
            STK_TO(0);

        }

        break;

    case KS_AST_IF:

        // first, generate the conditional
        // TODO: generate short-circuit jumping code
        codegen(self->v_if.cond, to, geni);

        // capture the position where the jump instruction begins
        int cond_jmpf_p = to->bc_n;
        // this will be filled in later
        ksc_jmpf(to, -1);
        // jmpf consumes one argument
        STK_GROW(-1);
        // capture the position where the jump shall be made from
        int cond_jmpf_a_p = to->bc_n;

        // next, generate the body
        codegen(self->v_if.body, to, geni);
        STK_TO(0);
        // capture the position after the body
        int body_a_p = to->bc_n;

        // now, get the actual instruction
        ksbc_i32* jmpf_i = (ksbc_i32*)(to->bc + cond_jmpf_p);

        // fill in the bytecode
        jmpf_i->i32 = body_a_p - cond_jmpf_a_p;

        break;

    default:
        kse_fmt("Given invalid AST (@%p) with type %i", self, self->atype);
        return;
        break;
    }

}


ks_code ks_ast_codegen(ks_ast self) {
    ks_list v_const = ks_list_new_empty();
    ks_code code = ks_code_new_empty(v_const);

    struct cgi geni;
    geni.last_main = NULL;
    geni.stk_depth = 0;
    geni.call_depth = 0;

    codegen(self, code, &geni);

    // end it with a noop, TODO: make it return
    ksc_noop(code);

    return code;
}


