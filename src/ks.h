/* ks.h - main header for the kscript library
 *
 * 
 * 
 * 
 * @author: Cade Brown <brown.cade@gmail.com>
 */

#ifndef KS_H__
#define KS_H__

#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include <string.h>
#include <assert.h>

// timing functions
#include <time.h>
#include <sys/time.h>

/* CONSTANTS */

// enumeration for levels of logging, from least important to most important
enum {
    // tracing, i.e. minute details will cover things such as allocations/deallocations,
    // and fine grained output. Some release builds may be built with tracing completely disabled,
    // so no output will show up from trace statements (to improve speeds of release builds)
    KS_LOG_TRACE = 0,

    // debug, i.e. occasional output will come from operations, such as large allocations/deallocations
    // (typically > 500MB), any odd occurences (for example, a dictionary having a lot of collisions
    // could be debugged, so that people can see that their dictionary building schemes are inefficient)
    // most builds are built with DEBUG support
    KS_LOG_DEBUG,
    
    // info, i.e. large operations (such as allocations/deallocations >= 10% of system memory), things such
    // as successful module imports, initialization information, etc
    KS_LOG_INFO,

    // warn, i.e. warning of odd/peculiar happenings that don't neccessarily halt the program, but should be
    // attended to, such as extremely large allocations >= 25% of system memory, a FILE read did not produce the
    // correct result to return (like fread(..., n, 1, fp) != n)), or a parameter was NULL
    // This is the default value for release software
    KS_LOG_WARN,

    // error, i.e. critical issues that cause problems if not paid any attention to.
    // this includes thrown exceptions which are not caught, a FILE was not opened correctly, 
    // a doublefree/corruption error occured, an object was NULL when it shouldn't have been
    // This is always printed out, can not be ignored by setting the logging level
    KS_LOG_ERROR,


    KS_LOG__END
};


/* BYTECODE 
 *
 * The format/syntax is SIZE:[type desc], i.e. 4:[int thing it does]
 * 
 * All instructions are at least 1 byte, and they start with the op code (i.e. 'KSB_*')
 * 
 * Some bytecodes have indexes that refer to the constants array, which is held by the code object
 * 
 * Terminology:
 *   TOS: Top Of Stack, i.e. the item that is on top of the stack
 *   UTOS: Under Top Of Stack, i.e. the item directly under the top of the stack
 * 
 */

// enumeration of all VM commands
enum {

    // Do nothing, just go to the next instruction. This should not be generated by code generators
    // 1:[op]
    KSB_NOOP = 0,


    /** STACK MANIPULATION, these opcodes do simple operations on the stack **/

    // Push a constant value onto the stack
    // 1:[op] 4:[int index into the 'v_const' array of code constants]
    KSB_PUSH,

    // Push a new reference of the TOS on top of the stack
    // 1:[op]
    KSB_DUP,

    // Pop off the TOS, and do not use it in any computation
    // 1:[op]
    KSB_POPU,


    /** CONTROL FLOW, these opcodes change the control flow of the function **/

    // Pop off 'n_items', and perform a function call with them
    // The item on the bottom of the stack
    // Example: if the stack is | A B C , then KSB_CALL(n_items=3) will result in calculating 'A(B, C)' 
    //   and pushing that result back on the stack
    // If there are not 'n_items' on the stack, internally abort
    // 1:[op] 4:[int n_items]
    KSB_CALL,

    // Pop off the TOS, and return that as the return value of the currently executing function,
    //   causing the top item of the stack frame to be popped off
    // 1:[op]
    KSB_RET,

    // Jump, unconditionally, a 'relamt' bytes in the bytecode, from the position where the next
    //   instruction would have been.
    // EX: jmp +0 is always a no-op, the program counter is not changed
    // EX: jmp -5 creates an infinite loop, because the jump instruction itself is 5 bytes,
    //       so it would jump back exactly one instruction
    // 1:[op] 4:[int relamt]
    KSB_JMP,

    // Pop off the TOS, get a truthiness value (default: 'true'), and if it was truthy,
    //   jump a specified number of bytes
    // EX: jmpt +10 will skip 10 bytes if the TOS was truthy
    // 1:[op] 4:[int relamt]
    KSB_JMPT,

    // Pop off the TOS, get a truthiness value (default: 'true'), and if it was NOT truthy,
    //   jump a specified number of bytes
    // EX: jmpf +10 will skip 10 bytes if the TOS was falsey
    // 1:[op] 4:[int relamt]
    KSB_JMPF,

    // Pop off the TOS, and 'throw' it up the call stack, rewinding, etc. If there was no
    //   'catch' block set up, then it will cause the program to abort and print an error
    // 1:[op]
    KSB_THROW,


    /** PRIMITIVE CONSTRUCTION, these opcodes create basic primitives from the stack **/

    // Pop off 'num_elems' from the stack, create a tuple from them, and then push that tuple
    //   back onto the stack
    // 1:[op] 4:[int num_elems, number of elements to take off the stack]
    KSB_TUPLE,

    // Pop off 'num_elems' from the stack, create a list from them, and then push that list
    //   back onto the stack
    // 1:[op] 4:[int num_elems, number of elements to take off the stack]
    KSB_LIST,

    
    /** VALUE LOOKUP **/

    // Load a value indicated by 'v_const[idx]' (being the string name), and push it on the stack
    // Raise an error if no such value was found
    // 1:[op] 4:[int idx into 'v_const']
    KSB_LOAD,

    // Pop off the TOS, then calculate getattr(TOS, v_const[idx]). Then, push that attribute on
    // Raise an error if no such attribute was found on the TOS
    // Internally abort if there was no item on TOS
    // 1:[op] 4:[int idx into 'v_const']
    KSB_LOAD_ATTR,

    // Store TOS into value 'v_const[idx]', creating it as a local if it was not found
    // Internally abort if there was no item on TOS
    // 1:[op] 4:[int idx into 'v_const']
    KSB_STORE,

    // Set an attribute to a value
    // Pop off the set UTOS.<attr> = TOS, then removes both, and pushes back on TOS
    // So stack goes from:
    // | UTOS TOS  -> set UTOS.<attr>=TOS -> | TOS
    // Internally abort if there was no item on TOS
    // 1:[op] 4:[int idx into 'v_const' of 'attr'1]
    KSB_STORE_ATTR,








};



/* TYPES */


// make sure these are aligned to a single byte
#pragma pack(push, 1)

// ksb - a single bytecode, i.e. sizeof(ksb) == 1
// can be part of the opcode, or any other parts
typedef uint8_t ksb;

// ksb_i32 - a sigle bytecode with a 32 bit signed integer component, sizeof(ksb_i32) == 5
typedef struct {

    ksb op;

    int32_t arg;

} ksb_i32;

// end single byte alignment
#pragma pack(pop)


// ks_size_t - type representing the size of something, i.e. unsigned and long enough to hold
//   64 bit indices
typedef uint64_t ks_size_t;

// ks_hash_t - type representing a hash of an object. 
// NOTE: hashes should never be '0', that means the hash is uninitialized or invalid
typedef uint64_t ks_hash_t;


// ks_obj - the most generic kscript object, which any other objects are castable to
typedef struct ks_obj* ks_obj;

// ks_str - a string object in kscript
typedef struct ks_str* ks_str;

// ks_type - an object representing a type in kscript. Every object has a type, which you can check with `obj->type`
typedef struct ks_type* ks_type;

// ks_list - an object representing an ordered list (i.e. array) of objects in kscript. note that this only holds references
//   to the objects; objects are not duplicated for the list
typedef struct ks_list* ks_list;

// ks_tuple - an object representing a tuple or collection of objects, which is immutable
typedef struct ks_tuple* ks_tuple;

// ks_dict - an object representing a generic object mapping, where an object of (most) types can be a key, and any type can be
//   a value
// Internally, a hash table implementation is used, similar to Python's
typedef struct ks_dict* ks_dict;



// Put this macro at the beginning of the definition of any kscript object, i.e.:
// struct my_obj {
//   KS_OBJ_BASE
//   int num;
//   ...
// }
// This will make it a valid kscript object type
#define KS_OBJ_BASE int64_t refcnt; ks_type type;

// Record a reference to a given object (i.e. increment the reference count)
#define KS_INCREF(_obj) { ++((ks_obj)_obj)->refcnt; }

// Un-record a reference to a given object (i.e. decrement the reference count)
// NOTE: If the reference count reaches 0 (i.e. the object has became unreachable), this frees
//   the object
#define KS_DECREF(_obj) { if (--((ks_obj)_obj)->refcnt <= 0) { ks_obj_free(((ks_obj)_obj)); } }


// Allocate memory for a new object type (by default, use `ks_malloc`)
// For example: `KS_ALLOC_OBJ(ks_int)` will allocate a `ks_int`
#define KS_ALLOC_OBJ(_typeName) ((_typeName)ks_malloc(sizeof(*(_typeName){NULL})))

// Free an object's memory (non-recursively; just the actual object pointer)
// Use this macro on things created with `KS_ALLOC_OBJ(_typeName)`
#define KS_FREE_OBJ(_obj) (ks_free((void*)(_obj)))

// Initialize an object of a given type, essentially setting its type as well as
// Setting its reference count to '1' (since it should be created with a reference)
// NOTE: This also increments the reference count of '_typeType'
#define KS_INIT_OBJ(_obj, _typeType) { \
    ks_obj obj = (ks_obj)(_obj); \
    ks_type typeType = (_typeType); \
    obj->type = typeType; \
    KS_INCREF(typeType); \
    obj->refcnt = 1; \
}

// Initialize an object that is itself a type
// Example: KS_INIT_TYPE_OBJ(ks_type_int, "int")
#define KS_INIT_TYPE_OBJ(_typeObj, _name) { \
    ks_init_type(_typeObj, _name); \
}

// Uninitialize an object, i.e. unrecord a reference to the type it has
#define KS_UNINIT_OBJ(_obj) { \
    ks_obj obj = (ks_obj)(_obj); \
    KS_DECREF(obj->type); \
}

// This will declare a ks_type variable of name `_type`, and an internal structure of `_type`_s
// EXAMPLE: KS_TYPE_DECLFWD(ks_type_int) defines `ks_type_int_s` and `ks_type_int`, but `ks_type_int`
//   is a static address; not allocated. So, the type is not generated at runtime, but rather is constant
#define KS_TYPE_DECLFWD(_type) struct ks_type _type##_s; ks_type _type = &_type##_s;


// This will define a function with '_name'+_, as a kscript C-extension function
// i.e.: KS_FUNC(add) will define a function called `add_`
#define KS_FUNC(_name) ks_obj _name##_(int n_args, ks_obj* args)

// This will define a function with '_type'_'_name'+_, as a kscript C-extension function
// i.e.: KS_TFUNC(int, add) will define a function called `int_add_`
#define KS_TFUNC(_type, _name) ks_obj _type##_##_name##_(int n_args, ks_obj* args)


struct ks_obj {
    KS_OBJ_BASE
};


// return a new reference to an object; use macro KS_NEWREF
static inline ks_obj ks_newref(ks_obj obj) {
    KS_INCREF(obj);
    return obj;
}

// This will create a new reference to '_obj', for ease of use returning functions
// NOTE: This also downcasts to 'ks_obj'
#define KS_NEWREF(_obj) ks_newref((ks_obj)(_obj))

struct ks_type {
    KS_OBJ_BASE

    // attributes of the type (i.e. member functions, static variables, etc)
    ks_dict attr;

    /* quick references: 
     *
     * These values are meant to be able to be quickly looked up, as they are builtins that will be called often.
     * These should always be equal to 'type.$NAME', so 'type->__str__' should always be equal to 
     *   'getattr(type, "__str__")'
     * 
     * The main reason for these attributes are speed of common operations, which this will allow us to skip a dict
     *   lookup, and instead just check
     * 
     */

    // type.__name__ -> the name of the type, typically human readable
    ks_str __name__;

    // type.__parents__ -> a list of parent classes from which this type derives from
    ks_list __parents__;


    // type.__str__(self) -> convert an item to a string
    ks_obj __str__;

    // type.__repr__(self) -> convert an item to a string representation
    ks_obj __repr__;

    // type.__new__(self) -> construct a new object of a given type. This should normally take 0 arguments
    //   and if '__init__' is not NULL, this should be called always with 0, then called __init__ with the resultant
    //   object and the rest of the arguments
    ks_obj __new__;

    // type.__init__(self) -> initialize an object (i.e. the second part of the constructor)
    ks_obj __init__;

    // type.__free__(self) -> free the memory/references used by the object
    ks_obj __free__;

    // type.__call__(self, *args) -> call 'self' like a function, given arguments
    ks_obj __call__;

    // type.__getattr__(self, attr) -> get an attribute from an object
    ks_obj __getattr__;

    // type.__setattr__(self, attr, val) -> set an attribute on an object
    ks_obj __setattr__;



};

struct ks_tuple {
    KS_OBJ_BASE

    // the number of items in the tuple
    ks_size_t len;

    // the address of the first item. The tuple is allocated with the items in the main buffer,
    // so this acts as the offset from the object pointer to the values
    // So, allocating a tuple is like: malloc(sizeof(struct ks_tuple) + len * sizeof(ks_obj))
    ks_obj elems[0];

};

struct ks_list {
    KS_OBJ_BASE

    // the number of items in the list
    ks_size_t len;

    // the array of elements, indexable starting at 0 to (len-1)
    ks_obj* elems;

};

struct ks_dict {
    KS_OBJ_BASE

    // the number of (active) entries in the hash table
    ks_size_t n_entries;

    struct ks_dict_entry {
        // hash(key), stored for efficiency reasons
        ks_hash_t hash;

        // the key of this entry
        // A reference is held to this
        ks_obj key;

        // the value of this entry
        // A reference is held to this
        ks_obj val;

    }* entries;

    // the number of buckets in the hash table (normally is a prime number)
    ks_size_t n_buckets;

    // the array of buckets (each bucket is an index into the 'entries' array, or -1 if it is empty, -2 if it has been deleted)
    int* buckets;

};

// special data structure for easier to read initialization from C, essentially
// each entry has a C-style string and a ks_obj that does not have an active reference in most cases
// i.e.:
// ks_dict_set_cn(dict, (ks_dict_ent_c[]){{"ExampleKey", (ks_obj)ks_int_new(43)}, {NULL, NULL}})
typedef struct {

    // NUL-terminated key (NULL key means this is the last C-style entry for the dictionary)
    char* key;

    // the value for the entry
    ks_obj val;

} ks_dict_ent_c;


// ks_none - the 'none' type in kscript
typedef struct {
    KS_OBJ_BASE

}* ks_none;

// the global singleton none
extern ks_none KS_NONE;

// down-casted constants so returning from functions is simpler
#define KSO_NONE ((ks_obj)KS_NONE)

// ks_bool - type representing either a 'true' or a 'false' value
// NOTE: These objects should not be created; just use the global singletons 'KS_TRUE' and 'KS_FALSE'
typedef struct {
    KS_OBJ_BASE

    // the actual boolean value
    bool val;

}* ks_bool;

// the global singletons for 'true' and 'false' respectively
extern ks_bool KS_TRUE, KS_FALSE;

// down-casted constants so returning from functions is simpler
#define KSO_TRUE ((ks_obj)KS_TRUE)
#define KSO_FALSE ((ks_obj)KS_FALSE)


// ks_int - type representing an integer value (signed, 64 bit) in kscript
typedef struct {
    KS_OBJ_BASE

    // the actual integer value
    int64_t val;

}* ks_int;

// ks_str - type representing a string of characters. Internally, the buffer is length encoded & NUL-terminated
//   and the hash is computed at creation time
struct ks_str {
    KS_OBJ_BASE

    // the hash of the string, cached, because it seems to be useful to precompute them
    ks_hash_t v_hash;

    // the number of characters in the string, not including a NUL-terminator
    // len("Hello") -> 5
    ks_size_t len;

    // the actual string value. In memory, ks_str's are allocated so that taking `->chr` just gives the address of
    // the start of the NUL-terminated part of the string. The [2] is to make sure that sizeof(ks_str) will allow
    // for enough room for two characters (this is useful for the internal constants for single-length strings),
    // and so new strings can be created with: `malloc(sizeof(*ks_str) + length)`
    char chr[2];

};

// ks_code - a bytecode object, which holds instructions to be executed
typedef struct {
    KS_OBJ_BASE

    // A reference to a list of constants, which are indexed by integers in the bytecode
    ks_list v_const;

    // number of bytes currently in the bytecode (bc)
    int bc_n;

    // a pointer to the actual bytecode, starting at index 0, through (bc_n-1)
    ksb* bc;


}* ks_code;




// ks_parser - an integrated parser which can parse kscript & bytecode to
//   ASTs & code objects
typedef struct ks_tok ks_tok;

// enumeration of different token types
enum {

    // whether the token is a valid type
    KS_TOK_NONE = 0,

    // Represents a combination of multiple tokens of different types
    KS_TOK_COMBO,

    // an identifier (i.e. any valid variable name)
    KS_TOK_IDENT,

    // an integer numerical literal (i.e. '123', '345', etc)
    KS_TOK_INT,

    // a string constant, wrapped in quotes (i.e. '"Abc\nDef"')
    KS_TOK_STR,

    // a comment token, which typically starts with '#' and goes until the end
    //   of the line
    KS_TOK_COMMENT,

    // a newline token, i.e. 
    //
    KS_TOK_NEWLINE,

    // End-Of-File token, always the last token for a given file
    KS_TOK_EOF,
    

    /** GRAMMAR CHARACTERS **/

    // a single left parenthesis i.e. '('
    KS_TOK_LPAR,
    // a single right parenthesis i.e. ')'
    KS_TOK_RPAR,

    // a single left bracket i.e. '['
    KS_TOK_LBRK,
    // a single right bracket i.e. ']'
    KS_TOK_RBRK,

    // a single left brace i.e. '{'
    KS_TOK_LBRC,
    // a single right brace i.e. '}'
    KS_TOK_RBRC,

    // a single dot/period i.e. '.'
    KS_TOK_DOT,
    // a single colon i.e. ':'
    KS_TOK_COL,
    // a single colon i.e. ';'
    KS_TOK_SEMI,

};

// ks_parser - an integrated parser which can parse kscript & bytecode to
//   ASTs & code objects
typedef struct {
    KS_OBJ_BASE
    
    // the source code the parser is parsing on
    ks_str src;

    // the current token index into the 'tok' array
    int toki;

    // number of tokens that were found
    int tok_n;

    // the array of tokens in the source code
    ks_tok* tok;

}* ks_parser;


// ks_tok - kscript token from parser
// These are not full 'objects', because that would require a lot of memory,
//   objects, and pointers for parsers. Many files have upwards of 10k tokens,
//   so allocating 10k objects & maintaining reference counts, etc would not
//   be feasible or as efficient
// Therefore, this structure does not hold a reference to 'parser',
//   since it is a part of a parser at all times, and the integer members
//   describe where in the source code the token is found
struct ks_tok {

    // the parser the token came from
    ks_parser parser;

    // the type of token, one of the KS_TOK_* enum values
    int type;

    // absolute position & length in the string source code
    int pos, len;

    // the line & column at which it first appeared
    int line, col;

};


// Different kinds of ASTs
enum {
    // Represents a constant, such as 'none', 'true', 'false', int, string
    // value is 'children[0]'
    KS_AST_CONST,

    // Represents a variable reference
    // name is 'children[0]'
    KS_AST_VAR,

    // Represents a function call, func(*args)
    // func is 'children[0]'
    // args are 'children[1:]
    KS_AST_CALL,

    // Represents a return statement (a return without a result should be filled
    //   with a 'none' constant)
    // result is 'children[0]'
    KS_AST_RET,

    // Represents a block of other ASTs
    // all children are in 'children'
    KS_AST_BLOCK,


    /** BINARY OPERATORS **/

    // binary '+'
    KS_AST_BOP_ADD,
    // binary '-'
    KS_AST_BOP_SUB,
    // binary '*'
    KS_AST_BOP_MUL,
    // binary '/'
    KS_AST_BOP_DIV,
    // binary '%'
    KS_AST_BOP_MOD,
    // binary '**'
    KS_AST_BOP_POW,

    // binary '<'
    KS_AST_BOP_LT,
    // binary '<='
    KS_AST_BOP_LE,
    // binary '>'
    KS_AST_BOP_GT,
    // binary '>='
    KS_AST_BOP_GE,
    // binary '=='
    KS_AST_BOP_EQ,
    // binary '!='
    KS_AST_BOP_NE,

    // binary '=' (special case, only assignable things area allowed on the left side)
    KS_AST_BOP_ASSIGN,


    /** UNARY OPERATORS **/

    // unary '-'
    KS_AST_UOP_NEG,
    // unary '~'
    KS_AST_UOP_SQIG,


};

// the first AST kind that is a binary operator
#define KS_AST_BOP__FIRST KS_AST_BOP_ADD

// the last AST kind that is a binary operator
#define KS_AST_BOP__LAST KS_AST_BOP_ASSIGN

// the first AST kind that is a unary operator
#define KS_AST_UOP__FIRST KS_AST_UOP_NEG

// the last AST kind that is a unary operator
#define KS_AST_UOP__LAST KS_AST_UOP_SQIG



// ks_ast - an Abstract Syntax Tree, a high-level representation of a program
typedef struct {
    KS_OBJ_BASE

    // the kind of AST it is
    int kind;

    // the array of children nodes. They are packed differently per kind, so see the definitino
    //   for a kind first
    ks_list children;

    // tokens for the AST, representing where it is in the source code
    ks_tok tok, tok_expr;

}* ks_ast;



// ks_vm - a virtual machine object, which can run kscript code & manage state
typedef struct {
    KS_OBJ_BASE

    // the execution stack, which holds values
    ks_list stk;

    // global variables
    ks_dict globals;

}* ks_vm;


// the default virtual machine to run code on
extern ks_vm ks_vm_default;


// ks_cfunc - a C-function wrapper which can be called the same as a kscript function
typedef struct {
    KS_OBJ_BASE

    // the actual C function which can be called
    ks_obj (*func)(int n_args, ks_obj* args);

}* ks_cfunc;



// ks_pfunc - a partial function wrapper, which wraps a callable with some of the arguments prefilled
// This is useful for member functions, for example, which have their first argument prefilled
typedef struct {
    KS_OBJ_BASE

    // the base function that will be called, and have its arguments filled in
    ks_obj func;

    // the number of arguments to fill in
    int n_fill;

    // list of indices & values to prefill in the call to func
    struct ks_pfunc_fill_arg {
        // 0-based index of where to insert it
        int idx;

        // the actual value provided as a prefill for the argument
        ks_obj arg;

    }* fill;

}* ks_pfunc;


// ks_Error - base class for an error. 
// NOTE: do not confuse this with 'ks_error' - that is a printing macro
typedef struct {
    KS_OBJ_BASE

    // attribute dictionary
    ks_dict attr;

}* ks_Error;


/* STRING BUILDING/UTILITY TYPES */

// ks_str_b - a string building utility to make string concatenation simpler
//   and more efficient
typedef struct {

    // the current length of the string builder
    int len;

    // the current character data for the string builder
    char* data;

} ks_str_b;



// Initialize the string builder
// NOTE: This must be called before `_get` or `_add*` methods
void ks_str_b_init(ks_str_b* self);

// Create a (new reference) of a string from the string builder at this point
ks_str ks_str_b_get(ks_str_b* self);

// Add character bytes to the string builder
void ks_str_b_add(ks_str_b* self, int len, char* data);

// Add a NUL-terminated C-style string to the buffer
void ks_str_b_add_c(ks_str_b* self, char* cstr);

// Add a formatted string (formmated by ks_vfmt), and then appended to the string buffer
void ks_str_b_add_fmt(ks_str_b* self, char* fmt, ...);

// Add repr(obj) to the string builder, returns true if it was fine, false if there was an error
bool ks_str_b_add_repr(ks_str_b* self, ks_obj obj);

// add str(obj) to the string buffer
bool ks_str_b_add_str(ks_str_b* self, ks_obj obj);

// Free the string builder, freeing all internal resources (but not the built strings)
void ks_str_b_free(ks_str_b* self);

/* meta-types */

// these are the built-in types
extern ks_type 
    ks_type_type,
    
    ks_type_none,
    ks_type_bool,
    ks_type_int,
    ks_type_str,
    ks_type_tuple,
    ks_type_list,
    ks_type_dict,

    ks_type_Error,

    ks_type_vm,
    ks_type_code,
    
    ks_type_cfunc

;

// these are the built-in functions

extern ks_cfunc
    ks_F_print
;


/* GENERIC/GENERAL LIBRARY FUNCTIONS */

// Attempt to initialize the library. Return 'true' on success, 'false' otherwise
bool ks_init();

// Type to hold a kscript version
typedef struct {
    
    // the semver <major>.<minor>.<patch> build
    int major, minor, patch;

    // the date of the compilation
    //   which is the '__DATE__' macro when it was compiled
    const char* date;

    // the time of the compilation,
    //   which is the '__TIME__' macro when it was compiled
    const char* time;

} ks_version_t;

// Get the version of kscript
// Do not free or modify this variable
const ks_version_t* ks_version();

// Return the time, in seconds, since the library started. It uses a fairly good wall clock,
//   but is only meant for rough approximation. Using the std time module is best for most results
double ks_time();

/* LOGGING */

// return the current logging level, one of KS_LOG_* enum values
int ks_log_level();

// set the logging level to `new_level`
void ks_log_level_set(int new_level);

// generically log given a level, the current file, line, and a C-style format string, with a list of arguments
// NOTE: don't use this, use the macros like `ks_info`, and `ks_warn`, which make it easier to use the logging
//   system
void ks_log(int level, const char *file, int line, const char* fmt, ...);

// prints a trace message, assuming the current log level allows for it
#define ks_trace(...) ks_log(KS_LOG_TRACE, __FILE__, __LINE__, __VA_ARGS__)
// prints a debug message, assuming the current log level allows for it
#define ks_debug(...) ks_log(KS_LOG_DEBUG, __FILE__, __LINE__, __VA_ARGS__)
// prints a info message, assuming the current log level allows for it
#define ks_info(...)  ks_log(KS_LOG_INFO, __FILE__, __LINE__, __VA_ARGS__)
// prints a warn message, assuming the current log level allows for it
#define ks_warn(...)  ks_log(KS_LOG_WARN, __FILE__, __LINE__, __VA_ARGS__)
// prints a error message, assuming the current log level allows for it
#define ks_error(...) ks_log(KS_LOG_ERROR, __FILE__, __LINE__, __VA_ARGS__)


/* MEMORY MANAGEMENT */

// Allocate at least 'sz' bytes, and return a pointer to that memory. `ks_malloc(0)` is guaranteed to return non-NULL
// NOTE: This memory must be free'd by `ks_free(ptr)`, and reallocated using `ks_realloc(ptr, new_sz)`
void* ks_malloc(ks_size_t sz);

// Attempt to reallocate 'ptr' (which was created using `ks_malloc`) to be at least 'new_sz' bytes. 
// NOTE: `ks_realloc(NULL, sz)` is the same as doing `ks_malloc(sz)`
void* ks_realloc(void* ptr, ks_size_t new_sz);

// Attempt to free 'ptr' (which must have been allocated using `ks_malloc` or `ks_realloc`)
// NOTE: `ks_free(NULL)` is a guaranteed NO-OP
void ks_free(void* ptr);

// Return the current amount of memory being used, or -1 if memory usage is not being tracked
int64_t ks_mem_cur();

// Return the maximum amount of memory that has been used at one time, or -1 if memory usage is not being tracked
int64_t ks_mem_max();


/* CREATING/DESTROYING PRIMITIVES */

/* TYPE */

// Initialize a type variable. Make sure 'self' has not been ref cnted, etc. Just an allocated blob of memory!
// NOTE: Returns a new reference
void ks_init_type(ks_type self, char* name);

// add a parent to the type, which the type will derive from
void ks_type_add_parent(ks_type self, ks_type parent);

// Get an attribute for the given type
// 0 can be passed to 'hash', and it will be calculated
// NOTE: Returns a new referece
ks_obj ks_type_get(ks_type self, ks_str key);

// Get a member function (self.attr), with the first argument filled as 'obj'
//   as the instance
// NOTE: Returns a new referece
ks_obj ks_type_get_mf(ks_type self, ks_str attr, ks_obj obj);

// Set an attribute for the given type
// 0 can be passed to 'hash', and it will be calculated
void ks_type_set(ks_type self, ks_str key, ks_obj val);

// Set a C-style string key as the attribute for a type
void ks_type_set_c(ks_type self, char* key, ks_obj val);

// Sets a list of C-entries (without creating new references)
// result == 0 means no problems
// result < 0 means there was some internal problem (most likely the key was not hashable)
// So, do NOT remove additional references from 'ent_cns'
int ks_type_set_cn(ks_type self, ks_dict_ent_c* ent_cns);



/* INT */

// Create a new kscript int from a C-style integer value
// NOTE: Returns a new reference
ks_int ks_int_new(int64_t val);


/* STR */

// Create a new kscript string from a C-style NUL-terminated string
// NOTE: Returns a new reference
ks_str ks_str_new(char* val);

// Create a new kscript string from a C-style length encoded string
// NOTE: Returns a new reference
ks_str ks_str_new_l(char* chr, int len);

// perform a string comparison on 2 strings
int ks_str_cmp(ks_str A, ks_str B);

// Escape the string 'A', i.e. replace '\' -> '\\', and newlines to '\n'
// NOTE: Returns a new reference
ks_str ks_str_escape(ks_str A);

// Undo the string escaping, i.e. replaces '\n' with a newline
// NOTE: Returns a new reference
ks_str ks_str_unescape(ks_str A);


/* TUPLE */

// Create a new kscript tuple from an array of elements, or an empty tuple if `len==0`
// NOTE: Returns a new reference
ks_tuple ks_tuple_new(int len, ks_obj* elems);


/* LIST */

// Create a new kscript list from an array of elements, or an empty list if `len==0`
// NOTE: Returns a new reference
ks_list ks_list_new(int len, ks_obj* elems);

// Push an object on to the end of the list, expanding the list
void ks_list_push(ks_list self, ks_obj obj);

// Push 'n' objects on to the end of the list, expanding the list
void ks_list_pushn(ks_list self, int n, ks_obj* objs);

// Pop off an object from the end of the list
// NOTE: Returns a reference
ks_obj ks_list_pop(ks_list self);

// Pop off 'n' items into 'dest'
// NOTE: Returns a reference to each object
void ks_list_popn(ks_list self, int n, ks_obj* dest);

// Pop off an object from the end of the list, destroying the reference
void ks_list_popu(ks_list self);


/* DICT */

// Create a new kscript dictionary from an array of entries (which should be 'len' number of key, val pairs)
// Example:
// ks_dict_new(3, (ks_obj[]){ key1, val1, key2, val2, key3, val3 })
// NOTE: Returns a new reference
ks_dict ks_dict_new(int len, ks_obj* entries);

// Create a new kscript dictionary from an array of C-style strings to values
// For example:
// ks_dict_new_cn((ks_dict_ent_cn[]){ {"Cade", myval}, {"Brown", otherval, {NULL, NULL}} });
// Will create a dictionary, and not introduce any memory leaks
// If you want to create values and transfer their references, see `ks_dict_new_cn` (n=no new references)
ks_dict ks_dict_new_c(ks_dict_ent_c* ent_cns);

// Create a new kscript dictionary from an array of C-style strings to values, which will not create new references to values
// The last key is 'NULL'
// For example:
// ks_dict_new_cn((ks_dict_ent_cn[]){ {"Cade", ks_int_new(42)}, {"Brown", ks_str_new("asdfasdf"), {NULL, NULL}} });
// Will create a dictionary, and not introduce any memory leaks
// If you're using already created variables, use `ks_dict_new_c()`, or replace the keys with `KS_NEWREF(key)`
ks_dict ks_dict_new_cn(ks_dict_ent_c* ent_cns);

// Test whether the dictionary has a given key. `hash` is always `hash(key)`. If it is 0, then 
//   attempt to calculate `hash(key)`. If it is 0, there is no error, but the dictionary is said to
//   not have the key
// For efficiency reasons, this allows the caller to precompute the hash from some other source,
//   so the dictionary doesn't have to
bool ks_dict_has(ks_dict self, ks_hash_t hash, ks_obj key);

// Get a value of the dictionary
// NULL if it does not exist
// NOTE: Returns a new reference
ks_obj ks_dict_get(ks_dict self, ks_hash_t hash, ks_obj key);

// Get a value of the dictionary
// NULL if it does not exist
// NOTE: Returns a new reference
ks_obj ks_dict_get_c(ks_dict self, char* key);

// Set a dictionary entry for a key, to a value
// If the entry already exists, dereference the old value, and replace it with the new value
// result > 0 means that an item was replaced
// result == 0 means no item was replaced, and there were no problems
// result < 0 means there was some internal problem (most likely the key was not hashable)
int ks_dict_set(ks_dict self, ks_hash_t hash, ks_obj key, ks_obj val);

// Delete an entry to the dictionary, returning 'true' if it was successful, false if it wasn't
bool ks_dict_del(ks_dict self, ks_hash_t hash, ks_obj key);

// Sets a list of C-entries (without creating new references)
// result == 0 means no problems
// result < 0 means there was some internal problem (most likely the key was not hashable)
int ks_dict_set_cn(ks_dict self, ks_dict_ent_c* ent_cns);


/* ERROR */

// Construct a new error from a string reason
// NOTE: Returns a new reference
ks_Error ks_Error_new(ks_str what);

// create a kscript error from a C style string
// NOTE: Returns a new reference
ks_Error ks_Error_new_c(char* what);

/* CODE */

// Create a new kscript code object, with a given constant list. The constant list can be non-empty,
//   in which case new constants will be allocated starting at the end. Cannot be NULL
// NOTE: Returns a new reference
ks_code ks_code_new(ks_list v_const);

// Output it to a binary encoded file, returning whether it was successful
bool ks_code_tofile(ks_code self, char* fname);

// Attempt to read from a binary file, returning 'NULL' if there was an error
ks_code ks_code_fromfile(char* fname);

// Append an array of bytecode to 'self'
void ks_code_add(ks_code self, int len, ksb* data);

// Add a constant to the internal constant list, return the index at which it was added (or already located)
int ks_code_add_const(ks_code self, ks_obj val);

/*** ADDING BYTECODES (see ks.h for bytecode definitions) ***/
void ksca_noop      (ks_code self);

void ksca_push      (ks_code self, ks_obj val);
void ksca_dup       (ks_code self);
void ksca_popu      (ks_code self);

void ksca_call      (ks_code self, int n_items);
void ksca_ret       (ks_code self);
void ksca_jmp       (ks_code self, int relamt);
void ksca_jmpt      (ks_code self, int relamt);
void ksca_jmpf      (ks_code self, int relamt);

void ksca_load      (ks_code self, ks_str name);
void ksca_load_attr (ks_code self, ks_str name);
void ksca_store     (ks_code self, ks_str name);
void ksca_store_attr(ks_code self, ks_str name);

// C-style versions
void ksca_load_c      (ks_code self, char* name);
void ksca_load_attr_c (ks_code self, char* name);
void ksca_store_c     (ks_code self, char* name);
void ksca_store_attr_c(ks_code self, char* name);


/* VM (Virtual Machine) */

// Create a new virtual machine
// NOTE: Returns a new reference
ks_vm ks_vm_new();


/* AST (Abstract Syntax Trees) */

// Create an AST representing a constant value
// Type should be none, bool, int, or str
// NOTE: Returns a new reference
ks_ast ks_ast_new_const(ks_obj val);

// Create an AST representing a variable reference
// Type should always be string
// NOTE: Returns a new reference
ks_ast ks_ast_new_var(ks_str name);

// Create an AST representing a function call
// NOTE: Returns a new reference
ks_ast ks_ast_new_call(ks_ast func, int n_args, ks_ast* args);

// Create an AST representing a return statement
// NOTE: Returns a new reference
ks_ast ks_ast_new_ret(ks_ast val);

// Create an AST representing a block of code
// NOTE: Returns a new reference
ks_ast ks_ast_new_block(int num, ks_ast* elems);

// Create a new AST represernting a binary operation on 2 objects
// NOTE: Returns a new reference
ks_ast ks_ast_new_bop(int bop_type, ks_ast L, ks_ast R);

// Create a new AST represernting a unary operation
// NOTE: Returns a new reference
ks_ast ks_ast_new_uop(int uop_type, ks_ast V);




/* PARSER */

// Create a new parser from some source code
// Or, return NULL if there was an error (and 'throw' the exception)
// NOTE: Returns a new reference
ks_parser ks_parser_new(ks_str src_code);

// Parse a single expression out of 'p'
// NOTE: Returns a new reference
ks_ast ks_parser_parse_expr(ks_parser self);

// Parse a single statement out of 'p'
// NOTE: Returns a new reference
ks_ast ks_parser_parse_stmt(ks_parser self);

// Parse the entire file out of 'p', returning the AST of the program
// Or, return NULL if there was an error (and 'throw' the exception)
// NOTE: Returns a new reference
ks_ast ks_parser_parse_file(ks_parser self);



/* CFUNC */

// Create a new C-function wrapper
// NOTE: Returns a new reference
ks_cfunc ks_cfunc_new(ks_obj (*func)(int n_args, ks_obj* args));


/* PFUNC */

// Create a new partial function wrapper
// NOTE: 'func' must be callable
// NOTE: Returns a new reference
ks_pfunc ks_pfunc_new(ks_obj func);

// Fill a given index with an argument
// NOTE: if 'idx' is already filled, it will be replaced
void ks_pfunc_fill(ks_pfunc self, int idx, ks_obj arg);




/* OBJECT INTERFACE (see ./obj.c) */

// Get the string representation of an object, or NULL if there was an error
// NOTE: Returns a new reference
ks_str ks_repr(ks_obj obj);

// Convert the given object to a string, or NULL if there was an error
// NOTE: Returns a new reference
ks_str ks_to_str(ks_obj obj);

// Free an object, by either calling its deconstructor or freeing the memory
void ks_obj_free(ks_obj obj);

// Return the length of the object (len(obj)) as an integer.
// Negative values indicate there was an exception
int64_t ks_len(ks_obj obj);

// Return the hash of the object (hash(obj)) as an integer.
// A return value of '0' indicates that there was some error with the hash function
//   (a hash function should never return 0)
ks_hash_t ks_hash(ks_obj obj);

// Return whether or not `A==B`. If the comparison is undefined, return 'false'
bool ks_eq(ks_obj A, ks_obj B);

// Return whether or not 'func' is callable as a function
bool ks_is_callable(ks_obj func);

// Get an attribute by name, i.e. 'obj.attr'
// NOTE: Returns a new reference
ks_obj ks_getattr(ks_obj obj, ks_obj attr);

// Get an attribute by name, i.e. 'obj.attr'
// NOTE: Returns a new reference
ks_obj ks_getattr_c(ks_obj obj, char* attr);

// Attempt to call 'func' on 'args', returning NULL if there was an error
// NOTE: Returns a new reference
ks_obj ks_call(ks_obj func, int n_args, ks_obj* args);

// Attempt to call 'func.attr' on 'args', returning NULL if there was an error
// NOTE: Returns a new reference
ks_obj ks_call_attr(ks_obj func, ks_obj attr, int n_args, ks_obj* args);

// Throw an object up the call stack
// NOTE: Throws an error if there is already an object on the call stack
// NOTE: Always returns NULL
void* ks_throw(ks_obj obj);

// Throw an error with a given format string, with an optional 'errtype' (which)
//   should always be allowed to set the '.what' attribute on
// NOTE: Throws an error if there is already an object on the call stack
// NOTE: Always returns NULL
void* ks_throw_fmt(ks_type errtype, char* fmt, ...);


// Attempt to catch an object from the call stack
// Returns 'NULL' if nothing has been thrown,
// otherwise, return the object that was thrown, and take it off the thrown location
// (so now other things can be thrown)
// NOTE: Returns a new reference, if it was non-NULL
ks_obj ks_catch();


/* STRING FORMATTING (see ./fmt.c) */

// Perform C-style formatting, with various arguments
// TODO: document format specifiers
// NOTE: Returns a reference
ks_str ks_fmt_c(const char* fmt, ...);

// Perform variadic C-style formating, with a list of arguments
// TODO: document format specifiers
// NOTE: Returns a reference
ks_str ks_fmt_vc(const char* fmt, va_list ap);


/* VM EXECUTION */

// Execute code on the VM
int vm_exec(ks_vm vm, ks_code code);



/* MISC. UTILS */

// Implementation of GNU getline function, reading an entire line from a FILE pointer
int ks_getline(char** lineptr, size_t* n, FILE* fp);

/* KSCRIPT FUNCTION ERROR HANDLING */

// Require an expression to be true, otherwise throw an error and return 'NULL'
// NOTE: Should be used inside of a KS_FUNC(), because this will return NULL!
#define KS_REQ(_expr, ...) {       \
    if (!(_expr)) {                \
        ks_error(__VA_ARGS__);     \
        return NULL;               \
    }                              \
}

// Require that the number of args is a specific amount
#define KS_REQ_N_ARGS(_nargs, _correct) KS_REQ((_nargs) == (_correct), "Incorrect number of arguments, expected %i, but got %i", (int)(_correct), (int)(_nargs))

// Require that the number of args is a specific amount
#define KS_REQ_N_ARGS_MIN(_nargs, _min) KS_REQ((_nargs) >= (_min), "Incorrect number of arguments, expected at least %i, but got %i", (int)(_min), (int)(_nargs))

// Require that the number of args is a specific amount
#define KS_REQ_N_ARGS_MAX(_nargs, _max) KS_REQ((_nargs) <= (_max), "Incorrect number of arguments, expected at most %i, but got %i", (int)(_max), (int)(_nargs))

// Require that the number of args is a specific amount
#define KS_REQ_N_ARGS_RANGE(_nargs, _min, _max) KS_REQ((_nargs) >= (_min) && (_nargs) <= (_max), "Incorrect number of arguments, expected between %i and %i, but got %i", (int)(_min), (int)(_max), (int)(_nargs))


// Require that the object is of a given type. 'name' is a C-string that is the human readable name for the variable
#define KS_REQ_TYPE(_obj, _type, _name) KS_REQ((_obj)->type == (_type), "Incorrect type for '%s', expected '%S', but got '%S'", _name, _type, (_obj)->type)




#endif /* KS_H__ */
