/* dict.c - dictionary implementation, based on hashtables


*/

#include "kscript.h"



// gets the object indexed by `key`. `hash` can be generated by calling `ks_hash(key)`
kso ks_dict_get(ks_dict* dict, kso key, ks_int hash) {
    // calculate the index into the items array
    int idx = hash % dict->n_buckets;

    // check that bucket, if no key even exists in that bucket, don't even search further
    if (dict->buckets[idx].key == NULL) return NULL;

    struct ks_dict_entry* entry = &dict->buckets[idx];

    while (entry != NULL) {
        if (entry->hash == hash) {
            // we have found a potential match, for now assume no hash collisions
            // in the future, also use an equals method to check `entry->key==key`
            return entry->val;
        }

        // iterate through
        entry = entry->next;
    }

    // we haven't found anything, return NULL
    return NULL;
}

// resizes to a new number of buckets
void ks_dict_resize(ks_dict* dict, int size) {
    if (dict->n_buckets >= size) return;
    //int old_size = dict->n_buckets;
    ks_dict new_dict = KS_DICT_EMPTY;
    new_dict.n_buckets = size;
    new_dict.buckets = ks_malloc(size * sizeof(*new_dict.buckets));
    int i;

    // empty all the buckets in the new one
    for (i = 0; i < new_dict.n_buckets; ++i) {
        new_dict.buckets[i] = KS_DICT_ENTRY_EMPTY;
    }

    // resize buckets

    for (i = 0; i < dict->n_buckets; ++i) {
        if (dict->buckets[i].key != NULL) {
            // a used bucket
            // add to the new dictionary
            //int idx = dict->buckets[i].hash % new_dict.n_buckets;
            ks_dict_set(&new_dict, dict->buckets[i].key, dict->buckets[i].hash, dict->buckets[i].val);

            struct ks_dict_entry* entry = dict->buckets[i].next;

            // loop through the linked list in the bucket
            while (entry != NULL) {
                ks_dict_set(&new_dict, entry->key, entry->hash, entry->val);
                entry = entry->next;
            }
        }
    }

    ks_dict_free(dict);

    // set to the new dict
    *dict = new_dict;
}


// sets the object indexed by `key`. `hash` can be generated by calling `ks_hash(key)`
void ks_dict_set(ks_dict* dict, kso key, ks_int hash, kso val) {

    // if it has a load factor of .5, resize to twice
    if (2 * dict->n_entries + 1 >= dict->n_buckets) {
        ks_dict_resize(dict, 2 * dict->n_entries + 1);
    }

    // increment their references, since they will both be in the dictionary now
    KSO_INCREF(key);
    KSO_INCREF(val);

    // calculate the index into the items array
    int idx = hash % dict->n_buckets;

    // check that bucket, if no key even exists in that bucket, we create it here
    if (dict->buckets[idx].key == NULL) {
        dict->buckets[idx] = (struct ks_dict_entry) {
            .hash = hash,
            .key = key,
            .val = val,
            .next = NULL
        };
        // we added an entry
        dict->n_entries++;
        return;
    }

    // else, we will need to traverse the linked list, trying to find a match
    struct ks_dict_entry* entry = &dict->buckets[idx];

    while (entry != NULL) {
        if (entry->hash == hash) {
            // possible match, now change the value

            // remove old value and replace
            kso old_val = entry->val;
            KSO_DECREF(old_val);
            entry->val = val;

            // done
            return;
        }

        // if we've hit the last entry
        if (entry->next == NULL) break;
        else {
            // iterate through the next
            entry = entry->next;
        }
    }

    // if we've hit this far, `entry` contains the last item in the linked list, so we need
    //   to append a new limb to the linked list
    struct ks_dict_entry* new_entry = ks_malloc(sizeof(*new_entry));

    // initialize it
    *new_entry = (struct ks_dict_entry) {
        .hash = hash,
        .key = key,
        .val = val,
        .next = NULL
    };

    // add it to the list
    entry->next = new_entry;

    // we added an entry
    dict->n_entries++;
    return;
}

kso ks_dict_get_str(ks_dict* dict, ks_str key, ks_int hash) {
    return ks_dict_get(dict, kso_new_str(key), hash);
}
void ks_dict_set_str(ks_dict* dict, ks_str key, ks_int hash, kso val) {
    ks_dict_set(dict, kso_new_str(key), hash, val);
}


void ks_dict_free(ks_dict* dict) {
    int i;
    for (i = 0; i < dict->n_buckets; ++i) {
        if (dict->buckets[i].key != NULL) {
            // we are in a used bucket
            // now, traverse the linked list
            struct ks_dict_entry* entry = dict->buckets[i].next, *next_entry = NULL;
            while (entry != NULL) {
                next_entry = entry->next;
                // free key/value
                KSO_DECREF(entry->key);
                KSO_DECREF(entry->val);
                // free the pointer itself
                ks_free(entry);

                // advance to next one
                entry = next_entry;
            }

            // free the root bucket key/values
            KSO_DECREF(dict->buckets[i].key);
            KSO_DECREF(dict->buckets[i].val);
        }
    }

    // free all the buckets
    ks_free(dict->buckets);

    *dict = KS_DICT_EMPTY;
}







