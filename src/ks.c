/* ks.c - the main commandline interface to kscript */

#include "ks.h"

/* for getopt */
#include <getopt.h>
#include <unistd.h>

int main(int argc, char** argv) {

    ks_init();
    ks_log_level_set(KS_LOG_INFO);

    size_t MU = ks_memuse();

    if (kse_dumpall()) return -1;

    // create a new virtual machine
    ks_vm vm = ks_vm_new_empty();
    #define SET_GLOBAL(_key, _val) { \
        ks_str skey = ks_str_new_r(_key); \
        ks_dict_set(vm->globals, (kso)skey, skey->v_hash, (kso)(_val)); \
        KSO_CHKREF(skey); \
    }

    SET_GLOBAL("print", ks_F_print);

    if (kse_dumpall()) return -1;

    // long options for commandline parsing
    static struct option long_options[] = {
        {"expr", required_argument, NULL, 'e'},
        {"file", required_argument, NULL, 'f'},
        {"help", no_argument, NULL, 'h'},

        {NULL, 0, NULL, 0}
    };

    // a parser, usable to parse expressions or files
    ks_parser par = NULL;

    // the AST for the whole program
    ks_ast prog_ast = NULL;

    // the generated bytecode for the program
    ks_code prog_bc = NULL;
    
    // getopt character
    int c;

    // error check
    if (kse_dumpall()) return -1;

    while ((c = getopt_long (argc, argv, "e:f:vih", long_options, NULL)) != -1)
    switch (c){
        case 'e':
            // do an expression given via commandline

            // construct a parser
            par = ks_parser_new_expr(optarg);
            if (kse_dumpall()) return -1;

            // parse out the whole expression            
            prog_ast = ks_parse_all(par);
            if (kse_dumpall()) return -1;

            // generate the bytecode
            prog_bc = ks_ast_codegen(prog_ast);
            if (kse_dumpall()) return -1;

            ks_debug("Running `-e`: '%s' (compiled to %ib)", par->src->chr, prog_bc->bc_n);
            // TODO: maybe output the assembly here

            // now, execute on the VM
            ks_vm_exec(vm, prog_bc);
            if (kse_dumpall()) return -1;

            // check refcnt
            KSO_CHKREF(par);
            KSO_CHKREF(prog_ast);
            KSO_CHKREF(prog_bc);

            break;
        case 'f':
            // do a file  given via commandline

            // construct a parser
            par = ks_parser_new_file(optarg);
            if (kse_dumpall()) return -1;

            // parse out the whole expression            
            prog_ast = ks_parse_all(par);
            if (kse_dumpall()) return -1;

            // generate the bytecode
            prog_bc = ks_ast_codegen(prog_ast);
            if (kse_dumpall()) return -1;

            ks_debug("Running `-f`: '%s' (compiled to %ib)", par->src_name->chr, prog_bc->bc_n);
            // TODO: maybe output the assembly here

            // now, execute on the VM
            ks_vm_exec(vm, prog_bc);
            if (kse_dumpall()) return -1;

            // check refcnt
            KSO_CHKREF(par);
            KSO_CHKREF(prog_ast);
            KSO_CHKREF(prog_bc);

            break;
        case 'v':
            // increase verbosity, decrease log level
            ks_log_level_set(ks_log_level() - 1);
            break;
        case 'i':
            printf("kscript v0.0, built at " __DATE__ " " __TIME__ "\n");
            printf("Authors:\n");
            printf("  Cade Brown <brown.cade@gmail.com>\n");

            return 0;
            break;
        case 'h':
            printf("Usage: %s [-e expr | -f file] [--h]\n", argv[0]);
            printf("  -h,--help              Prints this help message, then exits\n");
            printf("  -e,--expr [EXPR]       Compiles [EXPR], then executes it\n");
            printf("  -f,--file [FILE]       Reads [FILE], compiles it, then executes it\n");
            printf("  -i,--info              Prints build information, then exits\n");
            printf("  -v                     Increases the verbosity by one level (use -v -v for more verbosity)\n");
            return 0;
            break;
        case '?':
            if (strchr("e", optopt) != NULL) {
                ks_error("Option -%c requires an argument.", optopt);
            } else {
                ks_error("Unknown option `-%c'.", optopt);
            }
            return 1;
            break;
        default:
            return 1;
            break;
    }


    // now, execute the code
    ks_debug("memused: %lu", ks_memuse() - MU);
    
    KSO_CHKREF(vm);

    int total_diff = ks_memuse() - MU;
    if (total_diff != 0) ks_warn("possible leak of %lu bytes detected", total_diff);


    return 0;
}

