/* ks.c - the main commandline interface to kscript */

#include "ks.h"

/* for getopt */
#include <getopt.h>
#include <unistd.h>

int main(int argc, char** argv) {

    ks_init();
    ks_log_level_set(KS_LOG_INFO);

    // get the global virtual machine

    ks_dict globals = ks_get_globals();

    #define SET_GLOBAL(_key, _val) { \
        ks_str skey = ks_str_new(_key); \
        ks_dict_set(globals, (kso)skey, skey->v_hash, (kso)(_val)); \
        KSO_CHKREF(skey); \
    }

    SET_GLOBAL("print", ks_F_print);
    SET_GLOBAL("dict", ks_F_dict);
    SET_GLOBAL("type", ks_F_type);
    SET_GLOBAL("hash", ks_F_hash);
    SET_GLOBAL("call", ks_F_call);

    SET_GLOBAL("getattr", ks_F_getattr);
    SET_GLOBAL("setattr", ks_F_setattr);

    /* builtin types */
    SET_GLOBAL("list", ks_T_list);
    SET_GLOBAL("str", ks_T_str);
    SET_GLOBAL("int", ks_T_int);
    SET_GLOBAL("tuple", ks_T_tuple);


    if (kse_dumpall()) return -1;

    // long options for commandline parsing
    static struct option long_options[] = {
        {"expr", required_argument, NULL, 'e'},
        {"file", required_argument, NULL, 'f'},
        {"help", no_argument, NULL, 'h'},

        {NULL, 0, NULL, 0}
    };

    // a parser, usable to parse expressions or files
    ks_parser par = NULL;

    // the AST for the whole program
    ks_ast prog_ast = NULL;

    // the generated bytecode for the program
    ks_code prog_bc = NULL;

    // getopt character
    int c;

    // error check
    int64_t MU = ks_memuse();

    if (kse_dumpall()) return -1;

    while ((c = getopt_long (argc, argv, "e:f:vih", long_options, NULL)) != -1)
    switch (c){
        case 'e':
            // do an expression given via commandline

            // construct a parser
            par = ks_parser_new_expr(optarg);
            if (kse_dumpall()) return -1;
            KSO_INCREF(par);

            // parse out the whole expression            
            prog_ast = ks_parse_general(par);
            if (kse_dumpall()) return -1;
            KSO_INCREF(prog_ast);

            // generate the bytecode
            prog_bc = ks_ast_codegen(prog_ast, NULL);
            if (kse_dumpall()) return -1;
            KSO_INCREF(prog_bc);

            ks_debug("Running `-e`: '%s' (compiled to %ib)", par->src->chr, prog_bc->bc_n);
            // TODO: maybe output the assembly here

            // now, execute on the VM
            ks_vm_exec(prog_bc);
            if (kse_dumpall()) return -1;

            // check refcnt
            KSO_DECREF(par);
            KSO_DECREF(prog_ast);
            KSO_DECREF(prog_bc);

            break;
        case 'f':
            // do a file  given via commandline

            // construct a parser
            par = ks_parser_new_file(optarg);
            if (kse_dumpall()) return -1;
            KSO_INCREF(par);

            // parse out the whole expression            
            prog_ast = ks_parse_general(par);
            if (kse_dumpall()) return -1;
            KSO_INCREF(prog_ast);

            // generate the bytecode
            prog_bc = ks_ast_codegen(prog_ast, NULL);
            if (kse_dumpall()) return -1;
            KSO_INCREF(prog_bc);

            ks_debug("Running `-f`: '%s' (compiled to %ib)", par->src_name->chr, prog_bc->bc_n);
            // TODO: maybe output the assembly here

            // now, execute on the VM
            ks_vm_exec(prog_bc);
            if (kse_dumpall()) return -1;

            // check refcnt
            KSO_DECREF(par);
            KSO_DECREF(prog_ast);
            KSO_DECREF(prog_bc);

            break;
        case 'v':
            // increase verbosity, decrease log level
            ks_log_level_set(ks_log_level() - 1);
            break;
        case 'i':
            printf("kscript v0.0, built at " __DATE__ " " __TIME__ "\n");
            printf("Authors:\n");
            printf("  Cade Brown <brown.cade@gmail.com>\n");

            return 0;
            break;
        case 'h':
            printf("Usage: %s [-e expr | -f file] [--h]\n", argv[0]);
            printf("  -h,--help              Prints this help message, then exits\n");
            printf("  -e,--expr [EXPR]       Compiles [EXPR], then executes it\n");
            printf("  -f,--file [FILE]       Reads [FILE], compiles it, then executes it\n");
            printf("  -i,--info              Prints build information, then exits\n");
            printf("  -v                     Increases the verbosity by one level (use -v -v for more verbosity)\n");
            return 0;
            break;
        case '?':
            if (strchr("e", optopt) != NULL) {
                ks_error("Option -%c requires an argument.", optopt);
            } else {
                ks_error("Unknown option `-%c'.", optopt);
            }
            return 1;
            break;
        default:
            return 1;
            break;
    }

    // clean up memory, etc
    if (kse_dumpall()) return -1;

    int64_t total_diff = (int64_t)ks_memuse() - MU;
    if (total_diff != 0) ks_warn("possible leak of %l bytes detected", total_diff);

    ks_debug("memused: %l", ks_memuse_max());

    return 0;
}

