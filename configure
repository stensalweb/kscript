#!/usr/bin/env python3
""" configure - build configuration script, use like autotools

Usage: 
$ ./configure -h
[HELP MESSAGE]

$ ./configure && make


"""

import sys
import os
import subprocess
import platform
import glob

import argparse

print ("Python Version: " + str(sys.version))

class NegateAction(argparse.Action):
    def __call__(self, parser, ns, values, option):
        setattr(ns, self.dest, not option[2:].startswith('disable') and not option[2:].startswith('without') and not option[2:].startswith('no'))

parser = argparse.ArgumentParser(formatter_class=lambda prog: argparse.HelpFormatter(prog, max_help_position=40))

parser.add_argument('-V', nargs=3, type=int, help='The version of kscript (MAJOR, MINOR, PATCH)', default=[0, 0, 1])
parser.add_argument('--build-type', help='The build type that will be ran', choices=['debug', 'release'], default='release')
parser.add_argument('--dest-dir', help='Set the destination local directory (useful for making .deb packages, for example)', default=None)
parser.add_argument('--prefix', help='Set the prefix directory for installation', default=None)

all_modules = glob.glob("modules/*")
parser.add_argument('-M', nargs='*', help='Modules to build with kscript', default=all_modules)

# enable/disable features
parser.add_argument('--enable-trace', '--disable-trace', dest='trace', action=NegateAction, nargs=0, help='Enables/disables \'ks_trace()\', disabling may increase performance', default=True)
parser.add_argument('--enable-rpath', '--disable-rpath', dest='rpath', action=NegateAction, nargs=0, help='Enables/disables the use of local library paths, useful for local installations only. Use `--disable-rpath` for any packages/installed programs', default=True)

parser.add_argument('--with-gmp', '--without-gmp', dest='with_gmp', action=NegateAction, nargs=0, help='Enables/disables using the GNU MP (GMP) library for multiprecision', default=None)
parser.add_argument('--with-readline', '--without-readline', dest='with_readline', action=NegateAction, nargs=0, help='Enables/disables using the GNU readline library for command line interpreting', default=None)
parser.add_argument('--with-curl', '--without-curl', dest='with_curl', action=NegateAction, nargs=0, help='Enables/disables using the CURL library for network operations', default=None)
parser.add_argument('--with-glfw3', '--without-glfw3', dest='with_glfw3', action=NegateAction, nargs=0, help='Enables/disables using the GLFW3 library for GUI', default=None)
parser.add_argument('--with-libav', '--without-libav', dest='with_libav', action=NegateAction, nargs=0, help='Enables/disables using the libav (Audio/Video) library for multi-media operations', default=None)
parser.add_argument('--with-ffi', '--without-ffi', dest='with_ffi', action=NegateAction, nargs=0, help='Enables/disables using the FFI (Foreign Function Interface) library for Cfuncs', default=None)

args = parser.parse_args()

# -*- Config Vars

CC        = os.environ.get("CC",        "cc")
CFLAGS    = os.environ.get("CFLAGS",    "-O3 -std=c99")
LDFLAGS   = os.environ.get("LDFLAGS",   "")

PREFIX    = os.path.abspath(args.prefix if args.prefix else os.environ.get("PREFIX",    "/usr/local"))
DESTDIR   = args.dest_dir if args.dest_dir else os.environ.get("DESTDIR", "")

PWD       = os.getcwd()
_tmp      = PWD + "/.tmp"

LIB_FLAGS = ""


# list of -D defines
# for setting something, use 'KEY=VAL'
defs = [
	#"KEY=VAL"
	#"SOMEVAL"
]

# make the temporary directory
try:
	os.mkdir(_tmp)
except:
	pass

# -*- Tests

# run a shell command
def shell(cmd):
	return os.system(cmd) == 0

# run a shell command and get its (success, stdout)
def shell_output(cmd, simplify=True):
	res = subprocess.run(cmd.split(" "), stdout=subprocess.PIPE)
	src = res.stdout.decode('utf-8').strip()
	if simplify:
		src = src.replace("\n", " ")
	return res.returncode == 0, src

# test for a C library, and add relevant details to variables if so
def has_c_lib(name, cflag, lflag, header_block, body_block):
	global LIB_FLAGS
	global CFLAGS

	print (f" -- Searching for C library {name}...")
	print (f" --   Trying with:\n      cflag: '{cflag}'\n      lflag '{lflag}'\n      header '{header_block}'\n      code '{body_block}'")


	fname = _tmp + "/test.c"
	fp = open(fname, "w")
	fp.write(f"""

/* testing library '{name}' */

{header_block}

int main(int argc, char** argv) {{
	{body_block}
	return 0;
}}
	
""")
	fp.close()

	haslib = shell(f"{CC} {CFLAGS} {cflag} {fname} {LDFLAGS} {lflag} -o {_tmp}/a.out") and shell(f"{_tmp}/a.out")

	if not haslib:
		print (f" --   Not found!")
	else:
		# add to variables
		# remove definitions
		cflag = " ".join(filter(lambda arg: not arg.startswith("-D"), cflag.split(" ")))

		CFLAGS       += " " + cflag
		LIB_FLAGS    += " " + lflag

		print (f" --   Found!")


	return haslib


# adds a C check to the CFLAGS, useful for defining sizeof macros
def add_c_check(name, header_block, body_block):
	global CFLAGS
	global defs

	print (f" -- Running C check {name}...")

	fname = _tmp + "/test.c"
	fp = open(fname, "w")
	fp.write(f"""

/* C check */

{header_block}

int main(int argc, char** argv) {{
	{body_block}
	return 0;
}}
	
""")
	fp.close()

	# now, compile and run
	s0 = shell(f"{CC} {CFLAGS} {fname} {LDFLAGS} -o {_tmp}/a.out")
	if not s0:
		raise Exception(f"Compilation failed for C check '{name}'")

	print (f"{CC} {CFLAGS} {fname} {LDFLAGS} -o {_tmp}/a.out")
	s1, out = shell_output(f"{_tmp}/a.out")

	if not s1:
		raise Exception(f"Execution failed for C check '{name}'")

	print (f" --   Done, got: '{out}'")

	cfl_args = out.split(" ")

	for arg in cfl_args:
		if arg.startswith("-D"):
			defs = defs + [arg[2:].replace("=", " ", 1)]
		else:
			# add output to CFLAGS
			CFLAGS       += " " + arg



# which libraries we have
hasGMP         = False
hasREADLINE    = False
hasCURL        = False
hasGLFW3       = False
hasLIBAV       = False
hasFFI         = False


# search for libraries
if args.with_gmp is not False:
	hasGMP            = has_c_lib("GMP", shell_output("pkg-config --cflags gmp")[-1], shell_output("pkg-config --static --libs gmp")[-1], "#include <gmp.h>", "mpz_t x; mpz_init(x);")
	if args.with_gmp and not hasGMP:
		raise Exception("'--with-gmp' given, but GMP was not found!")

if args.with_readline is not False:
	hasREADLINE       = has_c_lib("readline", shell_output("pkg-config --cflags readline")[-1], "-lreadline", "#include <stdio.h>\n#include <readline/readline.h>", "rl_bind_key('\\t', rl_insert);")
	if args.with_readline and not hasREADLINE:
		raise Exception("'--with-readline' given, but readline was not found!")

if args.with_curl is not False:
	hasCURL           = has_c_lib("curl", "", "-lcurl", "#include <curl/curl.h>", "curl_global_init(CURL_GLOBAL_ALL);")
	if args.with_curl and not hasCURL:
		raise Exception("'--with-curl' given, but curl was not found!")

if args.with_glfw3 is not False:
	hasGLFW3          = has_c_lib("glfw3", shell_output("pkg-config --cflags glfw3")[-1], shell_output("pkg-config --static --libs glfw3")[-1], "#include <GLFW/glfw3.h>", "glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);")
	if args.with_glfw3 and not hasGLFW3:
		raise Exception("'--with-glfw3' given, but GLFW3 was not found!")

if args.with_libav is not False:
	hasLIBAV          = has_c_lib("libav", "", "-lavformat", "#include <libavutil/opt.h>\n#include <libavcodec/avcodec.h>\n#include <libavformat/avformat.h>", "AVFormatContext* format_ctx = avformat_alloc_context();")
	if args.with_libav and not hasLIBAV:
		raise Exception("'--with-libav' given, but LIBAV was not found!")

if args.with_ffi is not False:
	hasFFI            = has_c_lib("libffi", "", "-lffi", "#include <ffi.h>", "ffi_cif cif; ffi_type *args[1];")
	if args.with_ffi and not hasFFI:
		raise Exception("'--with-ffi' given, but FFI was not found!")




# add them to the defines
if hasGMP:        defs.append("KS_HAVE_GMP")

if hasREADLINE:   defs.append("KS_HAVE_READLINE")

if hasCURL:       defs.append("KS_HAVE_CURL")
else:             args.M = list(filter(lambda mod: mod not in ("modules/req", ), args.M))

if hasGLFW3:      defs.append("KS_HAVE_GLFW3")
else: args.M = list(filter(lambda mod: mod not in ("modules/cnk", ), args.M))

if hasLIBAV:      defs.append("KS_HAVE_LIBAV")
else: args.M = list(filter(lambda mod: mod not in ("modules/mm", ), args.M))

if hasFFI:        defs.append("KS_HAVE_FFI")
#else: args.M = list(filter(lambda mod: mod not in ("modules/mm", ), args.M))


# check for integer sizes
add_c_check("IntSizes", "#include <stdio.h>\n#include <stdint.h>", 'printf("-DSIZEOF_INT32_T=%zu -DSIZEOF_INT64_T=%zu -DSIZEOF_SIGNED_LONG=%zu -DSIZEOF_UNSIGNED_LONG=%zu\\n", sizeof(int32_t), sizeof(int64_t), sizeof(unsigned long), sizeof(signed long));')


# -*- Generate Files

# helper function to glob recursively and create a string of all results
def files(glob_pat, recursive=True):
    return " ".join(glob.glob(glob_pat, recursive=True))

# helper class for configuration
class _WithMessage:
	def __init__(self, name):
		self.name = name

	def __enter__(self):
		print (f" -- Configuring  '{self.name}'...")

	def __exit__(self, type, value, traceback):
		print (f" --   Done")


def genMsg(name, opts={}):
	print(" --- Configuring")


# command to run on 'makefile' target success
MAKE_success = '@echo "\\n|| Built: $@\\n"'

# newline
_newline = "\n"

## include/ks-config.h


# ending for a shared object (i.e. '.so' or '.dll')
SHARED_END = "so"
STATIC_END = "a"

KS_API_IMPORT = ""
KS_API_EXPORT = ""


# platforms
if sys.platform in ('linux', 'linux2'):
    defs.append("KS__LINUX")
elif sys.platform in ('darwin', ):
    defs.append("KS__MACOS")
elif sys.platform in ('win32', ):
    SHARED_END = "dll"
    STATIC_END = "lib"

    KS_API_IMPORT = "__declspec(dllimport)"
    KS_API_EXPORT = "__declspec(dllexport)"

    defs.append("KS__WINDOWS")

elif sys.platform in ('cygwin', ):
    SHARED_END = "dll"
    STATIC_END = "lib"

    KS_API_IMPORT = "__declspec(dllimport)"
    KS_API_EXPORT = "__declspec(dllexport)"

    defs.append("KS__CYGWIN")
else:
    defs.append("KS__OTHER")

defs.append("KS_SHARED_END \"" + SHARED_END + "\"")
defs.append("KS_STATIC_END \"" + STATIC_END + "\"")

warns = [

]

if "KS_OTHER" in defs:
    warns.append(f"Unknown platform '{sys.platform}' (from './configure' script)")


with _WithMessage("./include/ks-config"):

	f_config = open("./include/ks-config.h", "w")

	f_config.write(f"""/* ks_config.h - (generated by ./configure). Please rerun ./configure, and do NOT modify this file!
*
* Configure Script Ran:
* $ {" ".join(sys.argv)}
*
* Vars:
* CC            = {CC}
* CFLAGS        = {CFLAGS}
* LDFLAGS       = {LDFLAGS}
* PREFIX        = {PREFIX}
* DESTDIR       = {DESTDIR}
* PWD           = {PWD}
* V             = {args.V}
* BUILD_TYPE    = {args.build_type}
* MODULES       = {args.M}
*
*
* Misc.:
* sys.platform  = {sys.platform}
*
*/

#pragma once
#ifndef KS_CONFIG_H__
#define KS_CONFIG_H__

#ifdef __cplusplus
extern "C" {{
#endif


/* VERSION */

#define KS_VERSION_MAJOR {args.V[0]}
#define KS_VERSION_MINOR {args.V[1]}
#define KS_VERSION_PATCH {args.V[2]}

#define KS_BUILD_STR "{args.build_type}"
#define KS_BUILD_{args.build_type.upper()}


/* platform info */

#define KS_PLATFORM_NAME "{sys.platform}"

#define KS_API_EXPORT {KS_API_EXPORT}
#define KS_API_IMPORT {KS_API_IMPORT}

#ifdef KS_BUILD
#define KS_API KS_API_EXPORT
#else
#define KS_API KS_API_IMPORT
#endif

#define KS_PREFIX "{PREFIX}"


/* misc. defines */

{_newline.join("#define " + str(df) for df in defs)}


/* warnings */

{_newline.join("#warning " + str(df) for df in warns)}


#ifdef __cplusplus
}}
#endif

#endif /* KS_CONFIG_H__ */

""")

	f_config.close()


## ./Makefile

with _WithMessage("./Makefile"):
	f_Makefile = open("./Makefile", "w")

	f_Makefile.write(f"""# -*- Makefile (generated by ./configure). Please rerun ./configure, and do NOT modify this file! -*-

# -*- VARS -*-

SHARED_END       := {SHARED_END}
export SHARED_END
STATIC_END       := {STATIC_END}
export STATIC_END

STRIP_OPTS       ?= --strip-debug --strip-unneeded
export STRIP_OPTS

KS_VERSION_MAJOR := {args.V[0]}
export KS_VERSION_MAJOR
KS_VERSION_MINOR := {args.V[1]}
export KS_VERSION_MINOR
KS_VERSION_PATCH := {args.V[2]}
export KS_VERSION_PATCH

KS_VERSION       := $(KS_VERSION_MAJOR).$(KS_VERSION_MINOR).$(KS_VERSION_PATCH)
export KS_VERSION

CC               := {CC}
export CC
CFLAGS           := {CFLAGS}
export CFLAGS
LDFLAGS          := {LDFLAGS}
export LDFLAGS

# only should be enabled in local builds
RPATH_FLAGS      := {"-Wl,-rpath,'$$ORIGIN' -Wl,-rpath,'$$ORIGIN/../lib' -Wl,-rpath,./lib -Wl,-rpath-link,./" if args.rpath else ""}

KS_DIR           := {PWD}
export KS_DIR

PREFIX           ?= {PREFIX}
export PREFIX
DESTDIR          ?= {DESTDIR}
export DESTDIR

# static libraries that were built
_include_static := $(wildcard $(patsubst %,$(KS_DIR)/deps/prefix/lib/lib%.$(STATIC_END),gmp readline history))

_tmp             := {".tmp"}

STD_MODULES      := {" ".join(args.M)}

## modifying vars
CFLAGS           += -I{PWD}/include
LDFLAGS          += -L{PWD}/lib

# -*- FILES -*-

# general purpose headers
all_H            := $(wildcard include/*.h)
ks_H             := $(all_H)
export ks_H

# kscript library
libks_C          := {files("src/library/*.c")} {files("src/library/types/*.c")}

# kscript binary/commandline executable
ks_C             := {files("src/cmdline/*.c")}


# -*- TARGETS -*-

# target files
libks_SHARED     := {PWD}/lib/libks.$(SHARED_END)
export libks_SHARED
libks_STATIC     := {PWD}/lib/libks.$(STATIC_END)
export libks_STATIC
ks_BIN           := bin/ks

# generated
libks_O          := $(patsubst %.c,$(_tmp)/%.o,$(libks_C))
ks_O             := $(patsubst %.c,$(_tmp)/%.o,$(ks_C))


# -*- RULES -*-

.PHONY: all default clean install uninstall modules FORCE



# default target to build
default: $(libks_SHARED) modules $(ks_BIN)

# build everything
all: default

clean: FORCE
	rm -rf $(wildcard $(_tmp) debian/usr build lib bin *.deb)
	for subdir in $(STD_MODULES); do \\
		$(MAKE) -C $$subdir clean || exit 1 ; \\
	done

modules: $(libks_SHARED) FORCE
	for subdir in $(STD_MODULES); do \\
		$(MAKE) -C $$subdir || exit 1 ; \\
	done

# target to force another target
FORCE:

# rule to install the whole package to PREFIX
install: default $(libks_STATIC) $(ks_H) FORCE
	install -d $(DESTDIR)$(PREFIX)/bin/
	install -d $(DESTDIR)$(PREFIX)/lib/kscript/modules
	install -d $(DESTDIR)$(PREFIX)/share/doc/kscript
	install -d $(DESTDIR)$(PREFIX)/include/
	install -d $(DESTDIR)$(PREFIX)/share/man/man1

	install -m 755 $(ks_BIN) $(DESTDIR)$(PREFIX)/bin/
	install -m 644 $(libks_SHARED).$(KS_VERSION) $(libks_STATIC) $(DESTDIR)$(PREFIX)/lib/
	install -m 644 $(all_H) $(DESTDIR)$(PREFIX)/include/
	install -m 644 $(wildcard {PWD}/share/doc/*) $(DESTDIR)$(PREFIX)/share/doc/kscript
	install -m 644 $(wildcard {PWD}/share/man/man1/*) $(DESTDIR)$(PREFIX)/share/man/man1

	# add dependencies
	#install -m 644 $(wildcard deps/prefix/lib/*) $(DESTDIR)$(PREFIX)/lib/
	#install -m 644 $(wildcard deps/prefix/include/*) $(DESTDIR)$(PREFIX)/include/

	#mv $(DESTDIR)$(PREFIX)/lib/$(notdir $(libks_SHARED)) $(DESTDIR)$(PREFIX)/lib/$(notdir $(libks_SHARED)).$(KS_VERSION)

	rm -f $(DESTDIR)$(PREFIX)/lib/$(notdir $(libks_SHARED))
	ln -s libks.$(SHARED_END).$(KS_VERSION) $(DESTDIR)$(PREFIX)/lib/$(notdir $(libks_SHARED))

	gzip -9 -n -f $(DESTDIR)$(PREFIX)/share/doc/kscript/changelog
	mv $(DESTDIR)$(PREFIX)/share/doc/kscript/changelog.gz $(DESTDIR)$(PREFIX)/share/doc/kscript/changelog.Debian.gz

	gzip -9 -n -f $(DESTDIR)$(PREFIX)/share/man/man1/ks.1

	for subdir in $(STD_MODULES); do \\
		$(MAKE) -C $$subdir install || exit 1 ; \\
	done



# rule to uninstall the whole package from PREFIX
uninstall: FORCE
	rm -f $(DESTDIR)$(PREFIX)/bin/$(notdir $(ks_BIN))
	rm -f $(DESTDIR)$(PREFIX)/lib/$(notdir $(libks_STATIC)) $(DESTDIR)$(PREFIX)/lib/$(notdir $(libks_SHARED)) $(DESTDIR)$(PREFIX)/lib/$(notdir $(libks_SHARED)).$(KS_VERSION)
	rm -f $(patsubst %,$(DESTDIR)$(PREFIX)/include/%,$(notdir $(all_H)))

	for subdir in $(STD_MODULES); do \\
		$(MAKE) -C $$subdir uninstall || exit 1 ; \\
	done

# rule to compile a single object file
$(_tmp)/src/%.o: src/%.c $(all_H)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -DKS_BUILD $< -fPIC -c -o $@

# rule to build the shared object file (.so) from all the individual compilations
# Since `libks_o` contains many files, we use `$^` to mean `all input files together`
$(libks_SHARED): $(libks_O)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) \\
		$^ $(LDFLAGS) \\
		-Wl,-soname,libks.so.$(KS_VERSION) \\
		-Wl,-Bsymbolic \\
		-Wl,--whole-archive $(_include_static) -Wl,--no-whole-archive \\
		-shared {LIB_FLAGS} -o $@.$(KS_VERSION)
	strip $@.$(KS_VERSION) $(STRIP_OPTS)
	rm -f $@
	ln -s libks.$(SHARED_END).$(KS_VERSION) $@
	{MAKE_success}

# rule to build the static object file (.a)
$(libks_STATIC): $(libks_O)
	@mkdir -p $(dir $@)
	$(AR) cr $@ $^
	strip $@ $(STRIP_OPTS)
	{MAKE_success}

# rule to build the executable (no extension) from the library and it's `.o`'s
#   since we require a library, and object files, we don't use `$^`, but just build
#   explicitly
$(ks_BIN): $(libks_SHARED) $(ks_O)
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) $(ks_O) $(LDFLAGS) \\
		-L../lib -L{PWD}/lib $(RPATH_FLAGS) \\
		$(libks_SHARED).$(KS_VERSION) -lm -ldl -lpthread \\
		-o $@
	strip $@ $(STRIP_OPTS)
	{"cp $(libks_SHARED).$(KS_VERSION) $(dir $@)" if "KS__WINDOWS" in defs or "KS__CYGWIN" in defs else ""}
	{MAKE_success}



""")

	f_Makefile.close()



print ("-" * 80)

print (f"Configuration: kscript v{'.'.join(map(str, args.V))}")
print ("Modules:")

for mod in all_modules:
	print (f"  {'-+'[mod in args.M]} {mod}")


